name: Update Comprehensive SRS

on:
  workflow_dispatch:
  schedule:
    - cron: '0 20 * * *' # åŒ—äº¬æ—¶é—´å‡Œæ™¨ 4 ç‚¹è¿è¡Œ
  push:
    paths:
      - 'fakeip-filter-Remote-DNS.json'
      - '.github/workflows/**'

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install Dependencies
        run: pip install dnspython requests

      - name: Install sing-box
        run: |
          LATEST_TAG=$(curl -s "https://api.github.com/repos/SagerNet/sing-box/releases/latest" | grep -Po '"tag_name": "\K.*?(?=")')
          VERSION_NUM=${LATEST_TAG#v}
          curl -Lo sing-box.tar.gz "https://github.com/SagerNet/sing-box/releases/download/${LATEST_TAG}/sing-box-${VERSION_NUM}-linux-amd64.tar.gz"
          tar -xvf sing-box.tar.gz
          mv sing-box-*/sing-box .
          chmod +x sing-box

      # ----------------------------------------------------------------
      # é˜¶æ®µ 1: ç”ŸæˆåŸºç¡€ fakeip-filter.json (S1ç»å¯¹ä¿¡ä»» + S2/S3å…±è¯†)
      # ----------------------------------------------------------------
      - name: Advanced Consensus Merge (FakeIP)
        run: |
          curl -sL "https://raw.githubusercontent.com/77160860/rule/refs/heads/main/filter.json" -o s1.json
          curl -sL "https://github.com/DustinWin/ruleset_geodata/releases/download/sing-box-ruleset/fakeip-filter.srs" -o s2.srs
          ./sing-box rule-set decompile s2.srs -o s2.json
          curl -sL "https://raw.githubusercontent.com/HenryChiao/mihomo_yamls/refs/heads/main/custom/domain/fake-ip-filter.list" -o s3.list

          python3 -c "
          import json, re, os

          registry = {}
          
          def register(val, r_type, source_id):
              # æ ‡å‡†åŒ–å¤„ç†
              if r_type != 'regex': 
                  val = val.strip().lower()
              else:
                  # Regex ä¸å¼ºåˆ¶è½¬å°å†™ï¼Œä½†å»é™¤é¦–å°¾ç©ºæ ¼
                  val = val.strip()
              
              if not val: return
              if r_type != 'regex':
                  # ç®€å•çš„é•¿åº¦å’Œæ ¼å¼æ ¡éªŒ
                  if len(val) < 3 or ' ' in val: return
                  if re.match(r'^\d{1,3}(\.\d{1,3}){3}$', val): return
              
              key = f'{r_type}:{val}'
              if key not in registry: 
                  registry[key] = {'val': val, 'type': r_type, 'sources': set()}
              registry[key]['sources'].add(source_id)

          def load_json(path, sid):
              if not os.path.exists(path): return
              with open(path, 'r', encoding='utf-8') as f:
                  try:
                      d = json.load(f)
                      for r in d.get('rules', []):
                          for x in r.get('domain', []): register(x, 'domain', sid)
                          for x in r.get('domain_suffix', []): register(x, 'domain_suffix', sid)
                          for x in r.get('domain_keyword', []): register(x, 'domain_keyword', sid)
                          for x in r.get('domain_regex', []): register(x, 'domain_regex', sid)
                  except Exception as e:
                      print(f"Error loading {path}: {e}")

          # 1. åŠ è½½æ‰€æœ‰æº
          load_json('s1.json', 'S1')
          load_json('s2.json', 'S2')
          
          if os.path.exists('s3.list'):
              for line in open('s3.list', encoding='utf-8'):
                  l = line.strip()
                  if l and not l.startswith('#'):
                      if l.startswith('.'): register(l.lstrip('.'), 'domain_suffix', 'S3')
                      else: register(l, 'domain', 'S3')

          # 2. åˆå¹¶é€»è¾‘
          # è§„åˆ™ï¼šS1 å¿…é¡»ä¿ç•™ï¼›å‰©ä¸‹çš„ (S2, S3) å¿…é¡»äº¤å‰éªŒè¯ (å³åŒæ—¶å‡ºç°)
          final = {'domain': [], 'domain_suffix': [], 'domain_keyword': [], 'domain_regex': []}
          
          for key, info in registry.items():
              sources = info['sources']
              val = info['val']
              r_type = info['type']
              
              should_keep = False
              
              # S1 ç»å¯¹ä¿¡ä»»
              if 'S1' in sources:
                  should_keep = True
              # S2 å’Œ S3 å…±è¯†
              elif 'S2' in sources and 'S3' in sources:
                  should_keep = True
              else:
                  # å…¶ä»–æƒ…å†µï¼ˆå¦‚ä»… S2 æˆ– ä»… S3ï¼‰ä¸¢å¼ƒ
                  should_keep = False
                  
              if should_keep:
                  final[r_type].append(val)

          # 3. æ ¼å¼åŒ–è¾“å‡º
          with open('fakeip-filter.json', 'w', encoding='utf-8') as f:
              json.dump({'version': 3, 'rules': [{k: sorted(list(set(v))) for k, v in final.items() if v}]}, f, indent=2, ensure_ascii=False)
          "
          ./sing-box rule-set compile fakeip-filter.json -o fakeip-filter.srs

      # ----------------------------------------------------------------
      # é˜¶æ®µ 2: æ™ºèƒ½åˆ†æµæ¸…æ´— (Remote vs Local) - ä¸¥æ ¼æ‰§è¡Œæ’é™¤é€»è¾‘
      # ----------------------------------------------------------------
      - name: Classify Domains (Strict Filter)
        run: |
          # 1. ä¸‹è½½è¾…åŠ©æ•°æ®
          curl -sL "https://github.com/DustinWin/ruleset_geodata/releases/download/sing-box-ruleset/cn.srs" -o cn_full.srs
          ./sing-box rule-set decompile cn_full.srs -o cn_full.json
          
          curl -sL "https://github.com/DustinWin/ruleset_geodata/releases/download/sing-box-ruleset/private.srs" -o private.srs
          ./sing-box rule-set decompile private.srs -o private.json
          
          curl -sL "https://raw.githubusercontent.com/YiXuanZX/sing-box-geosite/main/rule/cn-additional-list-clash-classical.srs" -o cn-add.srs
          ./sing-box rule-set decompile cn-add.srs -o cn-add.json
          
          curl -sL "https://raw.githubusercontent.com/misakaio/chnroutes2/master/chnroutes.txt" -o chnroutes.txt

          python3 -c "
          import json, dns.resolver, ipaddress, concurrent.futures, os, re

          # --- A. æ„å»ºæœ¬åœ°åˆ¤æ–­åº“ ---
          local_exact_domains = set()
          local_suffixes = set()

          def load_local_whitelist(path):
              if not os.path.exists(path): return
              with open(path, 'r', encoding='utf-8') as f:
                  try:
                      d = json.load(f)
                      for r in d.get('rules', []):
                          # å¿½ç•¥é€»è¾‘åŒ¹é…ï¼Œåªå–çº¯åŸŸåæ•°æ®ç”¨äºæ’é™¤åˆ¤æ–­
                          for s in r.get('domain_suffix', []): local_suffixes.add(s.lower())
                          for x in r.get('domain', []): local_exact_domains.add(x.lower())
                  except: pass

          load_local_whitelist('cn_full.json')
          load_local_whitelist('private.json')
          load_local_whitelist('cn-add.json')

          # å¤„ç† IP åº“
          cn_nets = []
          if os.path.exists('chnroutes.txt'):
              cn_nets = [ipaddress.ip_network(l.strip()) for l in open('chnroutes.txt') if l.strip() and not l.startswith('#')]

          # --- B. å®šä¹‰åˆ¤æ–­å‡½æ•° ---

          resolver = dns.resolver.Resolver()
          resolver.nameservers = ['8.8.8.8', '1.1.1.1']
          resolver.timeout = 2
          resolver.lifetime = 2

          def is_local(domain_str):
              \"\"\"åˆ¤æ–­åŸŸåæ˜¯å¦å±äºæœ¬åœ°ï¼Œæ»¡è¶³ä»»ä¸€æ¡ä»¶å³è¿”å› True\"\"\"
              d_raw = domain_str.strip().strip('.')
              d_lower = d_raw.lower()

              # 1. åç¼€åŒ¹é…
              if d_lower.endswith('.cn'):
                  return True

              # 2. ç™½åå•ç²¾ç¡®åŒ¹é…
              if d_lower in local_exact_domains:
                  return True

              # 3. ç™½åå•åç¼€åŒ¹é… (æ£€æŸ¥ domain æ˜¯å¦è¢« local_suffixes è¦†ç›–)
              # è¿™é‡Œéœ€è¦åˆ¤æ–­ domain æ˜¯å¦ç­‰äº suffix æˆ–è€…ä»¥ suffix ç»“å°¾
              for s in local_suffixes:
                  if d_lower == s or d_lower.endswith('.' + s):
                      return True

              # 4. DNS è§£æéªŒè¯
              try:
                  ans = resolver.resolve(d_raw, 'A')
                  ip = ipaddress.ip_address(ans[0].to_text())
                  if any(ip in net for net in cn_nets):
                      return True
              except:
                  # è§£æå¤±è´¥æˆ–è¶…æ—¶ï¼Œæ— æ³•ç¡®è®¤ä¸ºæœ¬åœ°ï¼ŒæŒ‰è¿œç¨‹å¤„ç†ï¼ˆå³ä¸å‰”é™¤ï¼‰
                  pass
              
              return False

          def is_local_regex_keyword(rule_str, r_type):
              \"\"\"å¯¹ Regex å’Œ Keyword è¿›è¡Œç®€å•çš„æœ¬åœ°ç‰¹å¾æ’æŸ¥\"\"\"
              if '.cn' in rule_str.lower():
                  return True
              # å¯ä»¥åœ¨æ­¤æ·»åŠ æ›´å¤šé’ˆå¯¹æ­£åˆ™çš„å¤æ‚åˆ¤æ–­
              return False

          # --- C. å¤„ç†ä¸»é€»è¾‘ ---
          
          with open('fakeip-filter.json', 'r', encoding='utf-8') as f:
              source_data = json.load(f)

          final_remote = {'domain': [], 'domain_suffix': [], 'domain_keyword': [], 'domain_regex': []}
          
          # æå– source ä¸­çš„æ‰€æœ‰è§„åˆ™ (é€šå¸¸åªæœ‰ä¸€ä¸ª rule object)
          all_rules = {}
          for rule_block in source_data.get('rules', []):
              for k, v in rule_block.items():
                  all_rules[k] = v

          check_list = []

          # å‡†å¤‡éœ€è¦æ£€æŸ¥çš„ Domain å’Œ Suffix
          for d in all_rules.get('domain', []): check_list.append((d, 'domain'))
          for d in all_rules.get('domain_suffix', []): check_list.append((d, 'domain_suffix'))

          # å¤šçº¿ç¨‹æ£€æŸ¥ Domain å’Œ Suffix
          with concurrent.futures.ThreadPoolExecutor(max_workers=40) as executor:
              future_to_item = {executor.submit(is_local, item[0]): item for item in check_list}
              
              for future in concurrent.futures.as_completed(future_to_item):
                  d, t = future_to_item[future]
                  try:
                      local_flag = future.result()
                      if not local_flag:
                          final_remote[t].append(d)
                  except Exception as e:
                      # å‡ºé”™é»˜è®¤ä¿ç•™ï¼Œé˜²æ­¢æ¼æ€
                      final_remote[t].append(d)

          # å¤„ç† Keyword å’Œ Regex
          # åŸåˆ™ï¼šä¸è¿›è¡Œ DNS è§£æï¼Œä»…åšç®€å•çš„å­—ç¬¦ä¸²åˆ†æ
          for kw in all_rules.get('domain_keyword', []):
              if not is_local_regex_keyword(kw, 'keyword'):
                  final_remote['domain_keyword'].append(kw)
          
          for rx in all_rules.get('domain_regex', []):
              if not is_local_regex_keyword(rx, 'regex'):
                  final_remote['domain_regex'].append(rx)

          # --- D. æœ€ç»ˆå»é‡ä¸æ¸…ç† ---
          # å»é‡ï¼šå¦‚æœ suffix æ¶µç›–äº† domainï¼Œå‰”é™¤ domain
          s_set = set(final_remote['domain_suffix'])
          final_remote['domain'] = [d for d in final_remote['domain'] if not any(d.endswith('.' + s) or d == s for s in s_set)]

          # è¾“å‡ºç»“æœ
          with open('fakeip-filter-Remote-DNS.json', 'w', encoding='utf-8') as f:
              # æ’åºå¹¶ç”Ÿæˆ JSON
              output_rules = {}
              for k, v in final_remote.items():
                  if v:
                      output_rules[k] = sorted(list(set(v)))
              
              json.dump({'version': 3, 'rules': [output_rules]}, f, indent=2, ensure_ascii=False)
          "
          ./sing-box rule-set compile fakeip-filter-Remote-DNS.json -o fakeip-filter-Remote-DNS.srs

      # ----------------------------------------------------------------
      # é˜¶æ®µ 3: WebRTC & å…¶ä»– (ä¿æŒä¸å˜)
      # ----------------------------------------------------------------
      - name: Process WebRTC & Custom Rules
        run: |
          curl -sL "https://raw.githubusercontent.com/Kris-Channnn/sing-box-proxy/refs/heads/main/webRTC.json" -o raw_webrtc.json
          python3 -c "import json; d=json.load(open('raw_webrtc.json')); open('webRTC.json','w').write(json.dumps({'version': 3, 'rules': d.get('rules', [])}, indent=2))"
          ./sing-box rule-set compile webRTC.json -o webRTC.srs

      # ----------------------------------------------------------------
      # é˜¶æ®µ 4: æ¨é€
      # ----------------------------------------------------------------
      - name: Push to Repo
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "actions@github.com"
          rm -f s1.json s2.json s2.srs s3.list raw_webrtc.json \
                sing-box sing-box.tar.gz chnroutes.txt cn_full.srs cn_full.json \
                private.srs private.json cn-add.srs cn-add.json
          git add *.json *.srs
          if git diff --staged --quiet; then
            echo "No changes"
          else
            git commit -m "ğŸš€ Sync: Consensus Merge & Strict Filter ($(date +'%Y-%m-%d'))"
            git push origin main --force
          fi
