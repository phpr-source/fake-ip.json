name: Update Comprehensive SRS
on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'
  push:
    paths:
      - 'fakeip-filter-Remote-DNS.json'
      - '.github/workflows/**'

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: |
          pip install dnspython maxminddb
          # ä¸‹è½½ GeoLite2-Country æ•°æ®åº“
          curl -L "https://github.com/P3TERX/GeoLite.mmdb/raw/download/GeoLite2-Country.mmdb" -o GeoLite2-Country.mmdb
          # è·å– sing-box æœ€æ–°ç‰ˆ
          LATEST_TAG=$(curl -s "https://api.github.com/repos/SagerNet/sing-box/releases/latest" | grep -Po '"tag_name": "\K.*?(?=")')
          VERSION_NUM=${LATEST_TAG#v}
          curl -Lo sing-box.tar.gz "https://github.com/SagerNet/sing-box/releases/download/${LATEST_TAG}/sing-box-${VERSION_NUM}-linux-amd64.tar.gz"
          tar -xvf sing-box.tar.gz
          mv sing-box-*/sing-box .
          chmod +x sing-box

      - name: Smart IP-Verified Merge
        run: |
          # ä¸‹è½½æºæ–‡ä»¶
          curl -sL "https://raw.githubusercontent.com/77160860/rule/refs/heads/main/filter.json" -o s1.json
          curl -sL "https://github.com/DustinWin/ruleset_geodata/releases/download/sing-box-ruleset/fakeip-filter.srs" -o s2.srs
          ./sing-box rule-set decompile s2.srs -o s2.json
          curl -sL "https://raw.githubusercontent.com/HenryChiao/mihomo_yamls/refs/heads/main/custom/domain/fake-ip-filter.list" -o s3.list

          python3 <<EOF
          import json, re, os, socket, maxminddb
          from concurrent.futures import ThreadPoolExecutor

          # åˆå§‹åŒ–æ•°æ®åº“è¯»å–å™¨
          try:
              reader = maxminddb.open_database('GeoLite2-Country.mmdb')
          except Exception as e:
              print(f"âŒ æ— æ³•æ‰“å¼€æ•°æ®åº“: {e}")
              exit(1)

          registry = {}

          def register(val, r_type, source_id):
              val = val.strip().lower()
              if not val or len(val) < 3 or '/' in val or ':' in val: return
              if val not in registry:
                  registry[val] = {'sources': set(), 'types': set()}
              registry[val]['sources'].add(source_id)
              registry[val]['types'].add(r_type)

          # --- åŠ è½½æ‰€æœ‰æº ---
          def load_json(path, sid):
              if not os.path.exists(path): return
              with open(path, 'r') as f:
                  try:
                      data = json.load(f)
                      for r in data.get('rules', []):
                          for k in ['domain', 'domain_suffix', 'domain_keyword', 'domain_regex']:
                              for x in r.get(k, []): register(x, k.replace('domain_', ''), sid)
                  except: pass

          load_json('s1.json', 'S1')
          load_json('s2.json', 'S2')

          # å¤„ç† S3 (Clash æ ¼å¼åˆ—è¡¨)
          if os.path.exists('s3.list'):
              with open('s3.list', 'r') as f:
                  for line in f:
                      line = line.strip()
                      if not line or line.startswith('#'): continue
                      v = re.sub(r'^[+.]+', '', line)
                      register(v, 'suffix' if line.startswith('.') else 'domain', 'S3')

          # --- æ ¸å¿ƒï¼šIP å½’å±åœ°å¹¶å‘æ¢æµ‹ ---
          # åªå¯¹ç²¾ç¡®åŸŸåå’Œåç¼€è¿›è¡Œè§£æåˆ¤å®š
          all_domains = [v for v, info in registry.items() if any(t in ['domain', 'suffix'] for t in info['types'])]
          
          def check_ip_is_cn(d):
              try:
                  # è·å–ç¬¬ä¸€ä¸ª IP åœ°å€
                  ip = socket.gethostbyname(d)
                  res = reader.get(ip)
                  # åªè¦å›½å®¶ä»£ç æ˜¯ CNï¼Œå°±è®¤ä¸ºæ˜¯å›½å†…åŸŸå
                  if res and res.get('country', {}).get('iso_code') == 'CN':
                      return d, True
                  return d, False
              except:
                  # å¦‚æœè§£æå¤±è´¥ï¼ˆé€šå¸¸æ˜¯è¢«å¢™æˆ–æ­»é“¾ï¼‰ï¼Œé»˜è®¤å½’ç±»ä¸ºé CN (å³èµ° Remote æ›´ç¨³)
                  return d, False

          print(f"ğŸš€ å¼€å§‹æ¢æµ‹ {len(all_domains)} ä¸ªåŸŸåçš„åœ°ç†å½’å±...")
          with ThreadPoolExecutor(max_workers=20) as executor:
              results = dict(executor.map(check_ip_is_cn, all_domains))

          # --- åˆ†æµé€»è¾‘ ---
          fakeip_all = {'domain': [], 'domain_suffix': [], 'domain_keyword': [], 'domain_regex': []}
          remote_dns = {'domain': [], 'domain_suffix': [], 'domain_keyword': [], 'domain_regex': []}

          for val, info in registry.items():
              # S1 ä¿¡ä»»åŸåˆ™æˆ–å¤šæºå…±è¯†åŸåˆ™
              if 'S1' in info['sources'] or len(info['sources']) >= 2:
                  # ç¡®å®šæœ€ç»ˆåˆ†ç±»
                  if 'suffix' in info['types']: t = 'domain_suffix'
                  elif 'domain' in info['types']: t = 'domain'
                  elif 'keyword' in info['types']: t = 'domain_keyword'
                  else: t = 'domain_regex'
                  
                  fakeip_all[t].append(val)
                  
                  # åªæœ‰æ¢æµ‹ç»“æœä¸ºâ€œéä¸­å›½â€çš„åŸŸåæ‰è¿›å…¥ Remote-DNS
                  if not results.get(val, False):
                      remote_dns[t].append(val)

          # --- æ¸…ç†å†—ä½™ ---
          def clean(rules):
              s_set = set(rules['domain_suffix'])
              rules['domain'] = [d for d in rules['domain'] if not any(d.endswith('.' + s) or d == s for s in s_set)]
              return {k: sorted(list(set(v))) for k, v in rules.items() if v}

          final_fakeip = {'version': 3, 'rules': [clean(fakeip_all)]}
          final_remote = {'version': 3, 'rules': [clean(remote_dns)]}

          with open('fakeip-filter.json', 'w') as f: json.dump(final_fakeip, f, indent=2)
          with open('fakeip-filter-Remote-DNS.json', 'w') as f: json.dump(final_remote, f, indent=2)
          print("âœ… JSON ç”ŸæˆæˆåŠŸ")
          EOF

      - name: Process WebRTC & Compile
        run: |
          curl -sL "https://raw.githubusercontent.com/Kris-Channnn/sing-box-proxy/refs/heads/main/webRTC.json" -o raw_webrtc.json
          python3 -c "import json; d=json.load(open('raw_webrtc.json')); open('webRTC.json','w').write(json.dumps({'version': 3, 'rules': d.get('rules', [])}, indent=2))"
          
          ./sing-box rule-set compile fakeip-filter.json -o fakeip-filter.srs
          ./sing-box rule-set compile fakeip-filter-Remote-DNS.json -o fakeip-filter-Remote-DNS.srs
          ./sing-box rule-set compile webRTC.json -o webRTC.srs

      - name: Push to Repo
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "actions@github.com"
          rm -f *.mmdb s1.json s2.json s2.srs s3.list raw_webrtc.json sing-box*
          git add *.json *.srs
          git commit -m "ğŸš€ Update: IP-Verified Rules ($(date +'%Y-%m-%d'))" || exit 0
          git push origin main --force
