name: Update Comprehensive SRS
on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'
  push:
    paths:
      - 'fakeip-filter-Remote-DNS.json'
      - '.github/workflows/**'

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Latest sing-box
        run: |
          LATEST_TAG=$(curl -s "https://api.github.com/repos/SagerNet/sing-box/releases/latest" | grep -Po '"tag_name": "\K.*?(?=")')
          VERSION_NUM=${LATEST_TAG#v}
          curl -Lo sing-box.tar.gz "https://github.com/SagerNet/sing-box/releases/download/${LATEST_TAG}/sing-box-${VERSION_NUM}-linux-amd64.tar.gz"
          tar -xvf sing-box.tar.gz
          mv sing-box-*/sing-box .
          chmod +x sing-box

      - name: Advanced Consensus Merge (FakeIP)
        run: |
          # 1. ä¸‹è½½æº
          curl -sL "https://raw.githubusercontent.com/77160860/rule/refs/heads/main/filter.json" -o s1.json
          curl -sL "https://github.com/DustinWin/ruleset_geodata/releases/download/sing-box-ruleset/fakeip-filter.srs" -o s2.srs
          ./sing-box rule-set decompile s2.srs -o s2.json
          curl -sL "https://raw.githubusercontent.com/HenryChiao/mihomo_yamls/refs/heads/main/custom/domain/fake-ip-filter.list" -o s3.list

          python3 -c "
          import json, re, os

          registry = {}

          def register(val, r_type, source_id):
              val = val.strip().lower()
              # åŸºç¡€æ ¼å¼çº é”™ (ä¿æŒ Sing-box è¿è¡Œç¨³å®š)
              if not val or len(val) < 3 or ' ' in val or '/' in val or ':' in val: return
              if re.match(r'^\d{1,3}(\.\d{1,3}){3}$', val): return
              
              if val not in registry:
                  registry[val] = {'sources': set(), 'types': set()}
              registry[val]['sources'].add(source_id)
              registry[val]['types'].add(r_type)

          # åŠ è½½ JSON æº
          def load_json(path, sid):
              if not os.path.exists(path): return
              with open(path, 'r') as f:
                  data = json.load(f)
                  for r in data.get('rules', []):
                      for x in r.get('domain', []): register(x, 'domain', sid)
                      for x in r.get('domain_suffix', []): register(x, 'suffix', sid)
                      for x in r.get('domain_keyword', []): register(x, 'keyword', sid)
                      for x in r.get('domain_regex', []): register(x, 'regex', sid)

          load_json('s1.json', 'S1') # 77160860 åŸºå‡†æº
          load_json('s2.json', 'S2') # Dustin æº

          # åŠ è½½ List æº (S3) å¤„ç† Clash æ ¼å¼åˆ†ç±»
          with open('s3.list', 'r') as f:
              for line in f:
                  line = line.strip()
                  if not line or line.startswith('#'): continue
                  if line.startswith('+.') or line.startswith('.'):
                      register(re.sub(r'^[+.]+', '', line), 'suffix', 'S3')
                  else:
                      register(line, 'domain', 'S3')

          # å†³ç­–é€»è¾‘ï¼šä¿ç•™ 77160860 çš„å…¨éƒ¨ï¼Œæˆ–å…¶å®ƒä¸¤æºçš„äº¤é›†
          final_rules = {'domain': [], 'domain_suffix': [], 'domain_keyword': [], 'domain_regex': []}
          
          for val, info in registry.items():
              # æ ¸å¿ƒä¿®æ­£ï¼šS1(77160860) æ‹¥æœ‰ä¸€ç¥¨é€šè¿‡æƒï¼Œå¦åˆ™éœ€è¦ S2+S3 è¾¾æˆå…±è¯†
              if 'S1' in info['sources'] or len(info['sources']) >= 2:
                  # åˆ†ç±»å¯¹é½ï¼šåªè¦æœ‰ä¸€ä¸ªæºè®¤ä¸ºæ˜¯åç¼€ï¼Œå°±ä½œä¸ºåç¼€å¤„ç†
                  if 'suffix' in info['types']:
                      final_rules['domain_suffix'].append(val)
                  elif 'domain' in info['types']:
                      final_rules['domain'].append(val)
                  elif 'keyword' in info['types']:
                      final_rules['domain_keyword'].append(val)
                  elif 'regex' in info['types']:
                      final_rules['domain_regex'].append(val)

          # æ·±åº¦ä¼˜åŒ–ï¼šå‰”é™¤å·²è¢«åç¼€è¦†ç›–çš„é‡å¤ç²¾ç¡®åŸŸå
          s_set = set(final_rules['domain_suffix'])
          final_rules['domain'] = [d for d in final_rules['domain'] if not any(d.endswith('.' + s) or d == s for s in s_set)]

          # è¾“å‡ºè§„èŒƒçš„ Version 3 JSON
          output = {'version': 3, 'rules': [{k: sorted(v) for k, v in final_rules.items() if v}]}
          with open('fakeip-filter.json', 'w') as f:
              json.dump(output, f, indent=2)
          "
          ./sing-box rule-set compile fakeip-filter.json -o fakeip-filter.srs

      - name: Process WebRTC & Custom Rules
        run: |
          curl -sL "https://raw.githubusercontent.com/Kris-Channnn/sing-box-proxy/refs/heads/main/webRTC.json" -o raw_webrtc.json
          python3 -c "import json; f=open('raw_webrtc.json','r'); d=json.load(f); f.close(); open('webRTC.json','w').write(json.dumps({'version': 3, 'rules': d.get('rules', [])}, indent=2))"
          ./sing-box rule-set compile webRTC.json -o webRTC.srs
          
          if [ -f "fakeip-filter-Remote-DNS.json" ]; then
            ./sing-box rule-set compile fakeip-filter-Remote-DNS.json -o fakeip-filter-Remote-DNS.srs
          fi

      - name: Push to Repo
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "actions@github.com"
          rm -f s1.json s2.json s2.srs s3.list raw_webrtc.json sing-box sing-box.tar.gz
          git add *.json *.srs
          git commit -m "ğŸš€ Sync: Weighted Consensus (S1 Trusted) ($(date +'%Y-%m-%d'))" || exit 0
          git push origin main --force
